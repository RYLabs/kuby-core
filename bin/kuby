#! /usr/bin/env ruby

# The idea here is to be able to run the Kuby executable outside
# of a Bundler context. Kuby cannot both be part of the Rails app's
# bundle _and_ part of its own bundle since two bundles can pretty
# easily step on each other's toes (you get all sorts of unfriendly
# gem activation errors, etc). If kuby-core had no dependencies it
# wouldn't be as much of a problem. But because kuby-core depends
# on a number of additional gems, it needs bundler/rubygems to push
# the right versions of its dependencies onto the load path, require
# them, etc.
#
# Said another way, once code has been loaded into the Ruby VM, it's
# pretty hard to unload it. For that reason and the reasons above,
# this executable tries to load as little code as it can. It refrains
# from invoking Bundler or Rubygems, instead relying on the host Rails
# app to have included kuby-core in its Gemfile. Both Kuby::RailsCommands
# and Kuby::KubyCommands include setup code that require Bundler and
# ask it to set up the load path with all necessary gems.
#
# Moreover, we shouldn't have to require the entire bundle or the Rails
# environment every time we run a Kuby command. By requiring only the
# bare minimum here, we ensure faster execution times.

if Kernel.const_defined?(:Bundler)
  fail "Please run the Kuby CLI without Bundler, i.e. without 'bundle exec'"
end

# push only kuby and vendored GLI onto the load path
$:.push(File.expand_path(File.join('..', 'lib'), __dir__))
$:.push(File.expand_path(File.join('..', 'vendor', 'gems', 'gli', 'lib'), __dir__))

# we only need this (and GLI) to run
require 'kuby/commands'

exit Kuby::Commands.run(ARGV)
