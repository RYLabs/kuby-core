# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/statsd-instrument/all/statsd-instrument.rbi
#
# statsd-instrument-3.0.1

module StatsD
  def self.distribution(*args, &block); end
  def self.event(*args, &block); end
  def self.gauge(*args, &block); end
  def self.histogram(*args, &block); end
  def self.increment(*args, &block); end
  def self.logger; end
  def self.logger=(arg0); end
  def self.measure(*args, &block); end
  def self.service_check(*args, &block); end
  def self.set(*args, &block); end
  def self.singleton_client; end
  def self.singleton_client=(arg0); end
end
module StatsD::Instrument
  def add_to_method(method, name, action, &block); end
  def method_visibility(method); end
  def remove_from_method(method, name, action); end
  def self.current_timestamp; end
  def self.duration; end
  def self.generate_metric_name(name, callee, *args); end
  def statsd_count(method, name, sample_rate: nil, tags: nil, no_prefix: nil, client: nil); end
  def statsd_count_if(method, name, sample_rate: nil, tags: nil, no_prefix: nil, client: nil); end
  def statsd_count_success(method, name, sample_rate: nil, tags: nil, no_prefix: nil, client: nil); end
  def statsd_distribution(method, name, sample_rate: nil, tags: nil, no_prefix: nil, client: nil); end
  def statsd_instrumentation_for(method, name, action); end
  def statsd_instrumentations; end
  def statsd_measure(method, name, sample_rate: nil, tags: nil, no_prefix: nil, client: nil); end
  def statsd_remove_count(method, name); end
  def statsd_remove_count_if(method, name); end
  def statsd_remove_count_success(method, name); end
  def statsd_remove_distribution(method, name); end
  def statsd_remove_measure(method, name); end
end
class StatsD::Instrument::Client
  def capture(&block); end
  def capture_sink; end
  def clone_with_options(sink: nil, prefix: nil, default_sample_rate: nil, default_tags: nil, datagram_builder_class: nil); end
  def datagram_builder(no_prefix:); end
  def datagram_builder_class; end
  def default_sample_rate; end
  def default_tags; end
  def distribution(name, value = nil, sample_rate: nil, tags: nil, no_prefix: nil, &block); end
  def emit(datagram); end
  def event(title, text, timestamp: nil, hostname: nil, aggregation_key: nil, priority: nil, source_type_name: nil, alert_type: nil, tags: nil, no_prefix: nil); end
  def gauge(name, value, sample_rate: nil, tags: nil, no_prefix: nil); end
  def histogram(name, value, sample_rate: nil, tags: nil, no_prefix: nil); end
  def increment(name, value = nil, sample_rate: nil, tags: nil, no_prefix: nil); end
  def initialize(prefix: nil, default_sample_rate: nil, default_tags: nil, implementation: nil, sink: nil, datagram_builder_class: nil); end
  def latency(name, sample_rate: nil, tags: nil, metric_type: nil, no_prefix: nil); end
  def measure(name, value = nil, sample_rate: nil, tags: nil, no_prefix: nil, &block); end
  def prefix; end
  def sample?(sample_rate); end
  def self.datagram_builder_class_for_implementation(implementation); end
  def self.from_env(env = nil, prefix: nil, default_sample_rate: nil, default_tags: nil, implementation: nil, sink: nil, datagram_builder_class: nil); end
  def service_check(name, status, timestamp: nil, hostname: nil, tags: nil, message: nil, no_prefix: nil); end
  def set(name, value, sample_rate: nil, tags: nil, no_prefix: nil); end
  def sink; end
  def with_capture_sink(capture_sink); end
  def with_options(sink: nil, prefix: nil, default_sample_rate: nil, default_tags: nil, datagram_builder_class: nil); end
end
class StatsD::Instrument::Datagram
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(source); end
  def inspect; end
  def name; end
  def parsed_datagram; end
  def sample_rate; end
  def source; end
  def tags; end
  def type; end
  def value; end
end
class StatsD::Instrument::DogStatsDDatagram < StatsD::Instrument::Datagram
  def aggregation_key; end
  def alert_type; end
  def hostname; end
  def message; end
  def name; end
  def parsed_datagram; end
  def priority; end
  def source_type_name; end
  def timestamp; end
  def value; end
end
class StatsD::Instrument::DatagramBuilder
  def c(name, value, sample_rate, tags); end
  def d(name, value, sample_rate, tags); end
  def default_tags; end
  def g(name, value, sample_rate, tags); end
  def generate_generic_datagram(name, value, type, sample_rate, tags); end
  def h(name, value, sample_rate, tags); end
  def initialize(prefix: nil, default_tags: nil); end
  def kv(name, value, sample_rate, tags); end
  def latency_metric_type; end
  def ms(name, value, sample_rate, tags); end
  def normalize_name(name); end
  def normalize_tags(tags); end
  def prefix; end
  def s(name, value, sample_rate, tags); end
  def self.datagram_class; end
  def self.unsupported_datagram_types(*types); end
end
class StatsD::Instrument::StatsDDatagramBuilder < StatsD::Instrument::DatagramBuilder
  def d(_, _, _, _); end
  def h(_, _, _, _); end
  def kv(_, _, _, _); end
  def normalize_tags(tags); end
end
class StatsD::Instrument::DogStatsDDatagramBuilder < StatsD::Instrument::DatagramBuilder
  def _e(title, text, timestamp: nil, hostname: nil, aggregation_key: nil, priority: nil, source_type_name: nil, alert_type: nil, tags: nil); end
  def _sc(name, status, timestamp: nil, hostname: nil, tags: nil, message: nil); end
  def kv(_, _, _, _); end
  def latency_metric_type; end
  def self.datagram_class; end
end
class StatsD::Instrument::NullSink
  def <<(_datagram); end
  def sample?(_sample_rate); end
end
class StatsD::Instrument::UDPSink
  def <<(datagram); end
  def addr; end
  def host; end
  def initialize(host, port); end
  def invalidate_socket; end
  def port; end
  def sample?(sample_rate); end
  def self.for_addr(addr); end
  def socket; end
  def with_socket; end
end
class StatsD::Instrument::CaptureSink
  def <<(datagram); end
  def clear; end
  def datagram_class; end
  def datagrams; end
  def initialize(parent:, datagram_class: nil); end
  def parent; end
  def sample?(_sample_rate); end
end
class StatsD::Instrument::LogSink
  def <<(datagram); end
  def initialize(logger, severity: nil); end
  def logger; end
  def sample?(_sample_rate); end
  def severity; end
end
class StatsD::Instrument::Environment
  def client; end
  def default_sink_for_environment; end
  def env; end
  def environment; end
  def initialize(env); end
  def self.current; end
  def self.environment; end
  def self.setup; end
  def statsd_addr; end
  def statsd_default_tags; end
  def statsd_implementation; end
  def statsd_prefix; end
  def statsd_sample_rate; end
end
module StatsD::Instrument::Helpers
  def capture_statsd_calls(client: nil, &block); end
  def capture_statsd_datagrams(client: nil, &block); end
end
module StatsD::Instrument::Assertions
  def assert_no_statsd_calls(*metric_names, datagrams: nil, client: nil, &block); end
  def assert_statsd_calls(expectations, datagrams: nil, client: nil, &block); end
  def assert_statsd_distribution(metric_name, value = nil, datagrams: nil, client: nil, **options, &block); end
  def assert_statsd_expectation(expectations, datagrams: nil, client: nil, &block); end
  def assert_statsd_expectations(expectations, datagrams: nil, client: nil, &block); end
  def assert_statsd_gauge(metric_name, value = nil, datagrams: nil, client: nil, **options, &block); end
  def assert_statsd_histogram(metric_name, value = nil, datagrams: nil, client: nil, **options, &block); end
  def assert_statsd_increment(metric_name, value = nil, datagrams: nil, client: nil, **options, &block); end
  def assert_statsd_measure(metric_name, value = nil, datagrams: nil, client: nil, **options, &block); end
  def assert_statsd_set(metric_name, value = nil, datagrams: nil, client: nil, **options, &block); end
  def capture_statsd_datagrams_with_exception_handling(client:, &block); end
  include StatsD::Instrument::Helpers
end
class StatsD::Instrument::Expectation
  def initialize(type:, name:, client: nil, value: nil, sample_rate: nil, tags: nil, no_prefix: nil, times: nil); end
  def inspect; end
  def matches(actual_metric); end
  def name; end
  def name=(arg0); end
  def normalize_tags(tags); end
  def normalized_value_for_type(type, value); end
  def sample_rate; end
  def sample_rate=(arg0); end
  def self.distribution(name, value = nil, **options); end
  def self.gauge(name, value = nil, **options); end
  def self.histogram(name, value = nil, **options); end
  def self.increment(name, value = nil, **options); end
  def self.measure(name, value = nil, **options); end
  def self.set(name, value = nil, **options); end
  def tags; end
  def tags=(arg0); end
  def times; end
  def times=(arg0); end
  def to_s; end
  def type; end
  def type=(arg0); end
  def value; end
  def value=(arg0); end
end
class StatsD::Instrument::VoidClass
end
