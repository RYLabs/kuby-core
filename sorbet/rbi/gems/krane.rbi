# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/krane/all/krane.rbi
#
# krane-1.1.4

module Krane
end
class Object < BasicObject
  def JSON(*arg0); end
  def self.JSON(*arg0); end
  def to_json(*arg0); end
end
class OpenStruct
  def as_json(*arg0); end
  def self.json_create(h); end
end
class BigDecimal < Numeric
  def as_json(*arg0); end
  def self.new(*arg0); end
end
class Complex < Numeric
  def as_json(*arg0); end
  def self.rectangular(*arg0); end
end
class Date
  def as_json(*arg0); end
  def self.json_create(h); end
end
class DateTime < Date
  def as_json(*arg0); end
  def self.json_create(h); end
end
class Exception
  def as_json(*arg0); end
  def self.json_create(h); end
end
class Range
  def as_json(*arg0); end
  def self.json_create(h); end
end
class Rational < Numeric
  def as_json(*arg0); end
  def self.json_create(h); end
end
class Regexp
  def as_json(*arg0); end
  def self.json_create(h); end
end
class Struct
  def as_json(*arg0); end
  def self.json_create(h); end
end
class Symbol
  def as_json(*arg0); end
  def self.json_create(h); end
end
class Time
  def as_json(*arg0); end
  def self.json_create(h); end
end
module JSON
  def [](*arg0); end
  def create_id; end
  def create_id=(arg0); end
  def state; end
end
class Krane::FatalDeploymentError < StandardError
end
class Krane::FatalKubeAPIError < Krane::FatalDeploymentError
end
class Krane::KubectlError < StandardError
end
class Krane::TaskConfigurationError < Krane::FatalDeploymentError
end
class Krane::InvalidTemplateError < Krane::FatalDeploymentError
  def content; end
  def filename; end
  def filename=(arg0); end
  def initialize(err, filename: nil, content: nil); end
end
class Krane::DeploymentTimeoutError < Krane::FatalDeploymentError
end
class Krane::EjsonPrunableError < Krane::FatalDeploymentError
  def initialize; end
end
module Krane::DeferredSummaryLogging
  def blank_line(level = nil); end
  def heading(text, secondary_msg = nil, secondary_msg_color = nil); end
  def initialize(*args); end
  def phase_heading(phase_name); end
  def print_summary(status); end
  def reset; end
  def summary; end
end
class Krane::DeferredSummaryLogging::DeferredSummary
  def actions_sentence; end
  def add_action(sentence_fragment); end
  def add_paragraph(paragraph); end
  def initialize; end
  def paragraphs; end
end
class Krane::FormattedLogger < Logger
  def self.build(namespace = nil, context = nil, stream = nil, verbose_prefix: nil); end
  def self.indent_four(str); end
  def self.level_from_env; end
  include Krane::DeferredSummaryLogging
end
class Krane::StatsD
  def self.client; end
  def self.duration(start_time); end
end
module Krane::StatsD::MeasureMethods
  def measure_method(method_name, metric = nil); end
end
class Krane::ClusterResourceDiscovery
  def context(*args, &block); end
  def crds; end
  def fetch_api_versions; end
  def fetch_crds; end
  def fetch_resources(namespaced: nil); end
  def initialize(task_config:, namespace_tags: nil); end
  def kubectl; end
  def logger(*args, &block); end
  def namespace(*args, &block); end
  def prunable_resources(namespaced:); end
  def version_for_kind(versions, kind); end
end
class Krane::TaskConfig
  def context; end
  def global_kinds; end
  def initialize(context, namespace, logger = nil); end
  def logger; end
  def namespace; end
end
class Krane::TaskConfigValidator
  def context(*args, &block); end
  def errors; end
  def initialize(task_config, kubectl, kubeclient_builder, only: nil); end
  def logger(*args, &block); end
  def namespace(*args, &block); end
  def server_version_warning(server_version); end
  def valid?; end
  def validate_context_exists_in_kubeconfig; end
  def validate_context_reachable; end
  def validate_kubeconfig; end
  def validate_namespace_exists; end
  def validate_server_version; end
end
module Krane::Concurrency
  def self.split_across_threads(all_work, max_threads: nil, &block); end
end
class Krane::ResourceCache
  def context(*args, &block); end
  def fetch_by_kind(kind); end
  def get_all(kind, selector = nil); end
  def get_instance(kind, resource_name, raise_if_not_found: nil); end
  def initialize(task_config); end
  def logger(*args, &block); end
  def namespace(*args, &block); end
  def prewarm(resources); end
  def statsd_tags; end
  def use_or_populate_cache(kind); end
end
class Krane::ContainerLogs
  def container_name; end
  def empty?; end
  def fetch_latest; end
  def initialize(parent_id:, container_name:, namespace:, context:, logger:); end
  def kubectl; end
  def likely_duplicate?(timestamp); end
  def lines; end
  def print_all; end
  def print_latest(prefix: nil); end
  def printing_started?; end
  def rfc3339_timestamp(time); end
  def sort_and_deduplicate(logs); end
  def split_timestamped_line(log_line); end
  def sync; end
end
class Krane::RemoteLogs
  def container_logs; end
  def empty?; end
  def initialize(logger:, parent_id:, container_names:, namespace:, context:); end
  def print_all(prevent_duplicate: nil); end
  def print_latest; end
  def sync; end
end
class Krane::DurationParser
  def initialize(value); end
  def parse!; end
end
class Krane::DurationParser::ParsingError < ArgumentError
end
class Krane::LabelSelector
  def initialize(hash); end
  def self.parse(string); end
  def to_h; end
  def to_s; end
end
class Krane::RolloutConditionsError < StandardError
end
class Krane::RolloutConditions
  def failure_messages(instance_data); end
  def initialize(conditions); end
  def rollout_failed?(instance_data); end
  def rollout_successful?(instance_data); end
  def self.default_conditions; end
  def self.from_annotation(conditions_string); end
  def validate!; end
  def validate_conditions(conditions, source_key, required: nil); end
end
class Krane::KubernetesResource
  def <=>(other); end
  def after_sync; end
  def context; end
  def create_definition_tempfile; end
  def current_generation; end
  def debug_message(cause = nil, info_hash = nil); end
  def deploy_failed?; end
  def deploy_method; end
  def deploy_started?; end
  def deploy_started_at=(arg0); end
  def deploy_succeeded?; end
  def deploy_timed_out?; end
  def disappeared?; end
  def exists?; end
  def failure_message; end
  def fetch_events(kubectl); end
  def file; end
  def file_path; end
  def global=(arg0); end
  def global?; end
  def has_warnings?; end
  def id; end
  def initialize(namespace:, context:, definition:, logger:, statsd_tags: nil); end
  def krane_annotation_key(suffix); end
  def krane_annotation_value(suffix); end
  def kubectl_resource_type; end
  def labels; end
  def name; end
  def namespace; end
  def observed_generation; end
  def pretty_status; end
  def pretty_timeout_type; end
  def print_debug_logs?; end
  def report_status_to_statsd(watch_time); end
  def self.build(context:, definition:, logger:, statsd_tags:, namespace: nil, crd: nil, global_names: nil); end
  def self.class_for_kind(kind); end
  def self.kind; end
  def self.timeout; end
  def self.validate_definition_essentials(definition); end
  def sensitive_template_content?; end
  def server_dry_run_validated?; end
  def server_dry_runnable_resource?; end
  def statsd_tags; end
  def status; end
  def sync(cache); end
  def sync_debug_info(kubectl); end
  def terminating?; end
  def timeout; end
  def timeout_message; end
  def timeout_override; end
  def to_kubeclient_resource; end
  def type; end
  def type=(arg0); end
  def use_generated_name(instance_data); end
  def uses_generate_name?; end
  def validate_annotation_version; end
  def validate_definition(kubectl, selector: nil); end
  def validate_selector(selector); end
  def validate_spec_with_kubectl(kubectl); end
  def validate_timeout_annotation; end
  def validate_with_local_dry_run(kubectl); end
  def validate_with_server_side_dry_run(kubectl); end
  def validation_error_msg; end
  def validation_failed?; end
  def validation_warning_msg; end
end
class Krane::KubernetesResource::Event
  def initialize(subject_kind:, last_timestamp:, reason:, message:, count:, subject_name:); end
  def seen_since?(time); end
  def self.extract_all_from_go_template_blob(blob); end
  def self.extract_event_count(pieces); end
  def self.extract_event_timestamp(pieces); end
  def self.go_template_for(kind, name); end
  def to_s; end
end
class Krane::CustomResource < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def failure_message; end
  def initialize(namespace:, context:, definition:, logger:, crd:, statsd_tags: nil); end
  def kind; end
  def rollout_conditions; end
  def status; end
  def timeout; end
  def timeout_message; end
  def type; end
  def validate_definition(*arg0, **arg1); end
end
class Krane::ConfigMap < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end
class Krane::Pod < Krane::KubernetesResource
  def after_sync; end
  def deploy_failed?; end
  def deploy_succeeded?; end
  def failed_phase?; end
  def failed_schedule_reason; end
  def failure_message; end
  def fetch_debug_logs; end
  def initialize(namespace:, context:, definition:, logger:, statsd_tags: nil, parent: nil, deploy_started_at: nil, stream_logs: nil); end
  def logs; end
  def node_name; end
  def phase; end
  def phase_failure_message; end
  def print_debug_logs?; end
  def raise_predates_deploy_error; end
  def readiness_probe_failure?; end
  def ready?; end
  def reason; end
  def status; end
  def stream_logs; end
  def stream_logs=(arg0); end
  def sync(_cache); end
  def timeout_message; end
  def transient_failure_reason?; end
  def unmanaged?; end
  def update_container_statuses(status_data); end
end
class Krane::Pod::Container
  def doom_reason; end
  def doomed?; end
  def init_container?; end
  def initialize(definition, init_container: nil); end
  def name; end
  def readiness_fail_reason; end
  def ready?; end
  def reset_status; end
  def update_status(data); end
end
class Krane::PodSetBase < Krane::KubernetesResource
  def container_names; end
  def failure_message; end
  def fetch_debug_logs; end
  def fetch_events(kubectl); end
  def find_pods(cache); end
  def parent_of_pod?(_); end
  def pods; end
  def print_debug_logs?; end
  def timeout_message; end
end
class Krane::ReplicaSet < Krane::PodSetBase
  def available_replicas; end
  def deploy_failed?; end
  def deploy_succeeded?; end
  def desired_replicas; end
  def initialize(namespace:, context:, definition:, logger:, statsd_tags: nil, parent: nil, deploy_started_at: nil); end
  def parent_of_pod?(pod_data); end
  def pods; end
  def ready_replicas; end
  def rollout_data; end
  def stale_status?; end
  def status; end
  def sync(cache); end
  def unmanaged?; end
end
class Krane::Deployment < Krane::KubernetesResource
  def current_generation; end
  def deploy_failed?; end
  def deploy_failing_to_progress?; end
  def deploy_succeeded?; end
  def deploy_timed_out?; end
  def desired_replicas; end
  def failure_message; end
  def fetch_debug_logs; end
  def fetch_events(kubectl); end
  def find_latest_rs(cache); end
  def max_unavailable; end
  def min_available_replicas; end
  def observed_generation; end
  def percent?(value); end
  def pretty_timeout_type; end
  def print_debug_logs?; end
  def progress_condition; end
  def progress_deadline; end
  def required_rollout; end
  def rollout_annotation_err_msg; end
  def rollout_data; end
  def status; end
  def sync(cache); end
  def timeout_message; end
  def validate_definition(*arg0, **arg1); end
end
class Krane::Ingress < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
end
class Krane::PersistentVolumeClaim < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def failure_message; end
  def status; end
  def storage_class; end
  def storage_class_name; end
  def sync(cache); end
  def timeout_message; end
end
class Krane::PersistentVolumeClaim::StorageClass < Krane::KubernetesResource
  def default?; end
  def initialize(definition); end
  def name; end
  def volume_binding_mode; end
end
class Krane::NetworkPolicy < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end
class Krane::Service < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def exposes_zero_replica_workload?; end
  def external_name_svc?; end
  def fetch_related_workloads(cache); end
  def published?; end
  def related_replica_count; end
  def requires_endpoints?; end
  def requires_publishing?; end
  def selector; end
  def selects_some_pods?; end
  def status; end
  def sync(cache); end
  def timeout_message; end
end
class Krane::PodTemplate < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end
class Krane::PodDisruptionBudget < Krane::KubernetesResource
  def deploy_method; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end
class Krane::ServiceAccount < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end
class Krane::DaemonSet < Krane::PodSetBase
  def deploy_failed?; end
  def deploy_succeeded?; end
  def fetch_debug_logs; end
  def find_nodes(cache); end
  def parent_of_pod?(pod_data); end
  def pods; end
  def print_debug_logs?; end
  def relevant_pods_ready?; end
  def rollout_data; end
  def status; end
  def sync(cache); end
end
class Krane::DaemonSet::Node
  def initialize(definition:); end
  def name; end
  def self.kind; end
end
class Krane::ResourceQuota < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end
class Krane::StatefulSet < Krane::PodSetBase
  def deploy_failed?; end
  def deploy_succeeded?; end
  def desired_replicas; end
  def parent_of_pod?(pod_data); end
  def pods; end
  def status; end
  def status_data; end
  def sync(cache); end
  def update_strategy; end
end
class Krane::CronJob < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def timeout_message; end
end
class Krane::Job < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def done?; end
  def failed_status_condition; end
  def failure_message; end
  def running?; end
  def status; end
end
class Krane::CustomResourceDefinition < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def group_version_kind; end
  def kind; end
  def names_accepted_condition; end
  def names_accepted_status; end
  def predeployed?; end
  def prunable?; end
  def rollout_conditions; end
  def status; end
  def timeout_for_instance; end
  def timeout_message; end
  def validate_definition(*arg0, **arg1); end
  def validate_rollout_conditions; end
end
class Krane::HorizontalPodAutoscaler < Krane::KubernetesResource
  def able_to_scale_condition; end
  def conditions; end
  def deploy_failed?; end
  def deploy_succeeded?; end
  def failure_message; end
  def kubectl_resource_type; end
  def scaling_active_condition; end
  def scaling_disabled?; end
  def status; end
  def timeout_message; end
end
class Krane::Secret < Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end
class Krane::ResourceWatcher
  def context(*args, &block); end
  def due_for_reminder?(last_message_logged_at, reminder_interval); end
  def global_timeout?(started_at); end
  def initialize(resources:, task_config:, deploy_started_at: nil, operation_name: nil, timeout: nil, sha: nil); end
  def logger(*args, &block); end
  def namespace(*args, &block); end
  def past_tense_operation; end
  def record_failed_statuses(failed_resources, global_timeouts = nil); end
  def record_statuses_for_summary(resources); end
  def record_success_statuses(successful_resources); end
  def report_and_give_up(remaining_resources); end
  def report_what_is_left(resources, reminder:); end
  def report_what_just_happened(new_successes, new_failures, new_timeouts); end
  def run(delay_sync: nil, reminder_interval: nil, record_summary: nil); end
  def sleep_until_next_sync(min_interval); end
  def statsd_tags; end
  def sync_resources(*args, **kwargs, &block); end
  extend Krane::StatsD::MeasureMethods
end
module Krane::ResourceWatcher::InstrumentationProxy
  def sync_resources(*args, **kwargs, &block); end
end
class Krane::Kubectl
  def build_command_from_options(args, use_namespace, use_context, output); end
  def client_version; end
  def context(*args, &block); end
  def extract_version_info_from_kubectl_response(response); end
  def initialize(task_config:, log_failure_by_default:, default_timeout: nil, output_is_sensitive_default: nil); end
  def logger(*args, &block); end
  def namespace(*args, &block); end
  def retriable_err?(err, retry_whitelist); end
  def retry_delay(attempt); end
  def run(*args, log_failure: nil, use_context: nil, use_namespace: nil, output: nil, raise_if_not_found: nil, attempts: nil, output_is_sensitive: nil, retry_whitelist: nil); end
  def server_dry_run_enabled?; end
  def server_version; end
  def version_info; end
end
class Krane::Kubectl::ResourceNotFoundError < StandardError
end
class Krane::KubeclientBuilder
  def build_apiextensions_v1beta1_kubeclient(context); end
  def build_apps_v1_kubeclient(context); end
  def build_autoscaling_v1_kubeclient(context); end
  def build_batch_v1_kubeclient(context); end
  def build_batch_v1beta1_kubeclient(context); end
  def build_kubeclient(api_version:, context:, endpoint_path: nil); end
  def build_networking_v1_kubeclient(context); end
  def build_policy_v1beta1_kubeclient(context); end
  def build_rbac_v1_kubeclient(context); end
  def build_scheduling_v1beta1_kubeclient(context); end
  def build_storage_v1_kubeclient(context); end
  def build_v1_kubeclient(context); end
  def build_v1beta1_kubeclient(context); end
  def initialize(kubeconfig: nil); end
  def validate_config_files!; end
  def validate_config_files; end
end
class Krane::KubeclientBuilder::ContextMissingError < Krane::FatalDeploymentError
  def initialize(context_name, kubeconfig); end
end
class Krane::EjsonSecretError < Krane::FatalDeploymentError
  def initialize(msg); end
end
class Krane::EjsonSecretProvisioner
  def build_secrets; end
  def context(*args, &block); end
  def decrypt_ejson(key_dir); end
  def encrypted_ejson; end
  def fetch_private_key_from_secret; end
  def generate_secret_resource(secret_name, secret_type, data); end
  def initialize(task_config:, ejson_keys_secret:, ejson_file:, statsd_tags:, selector: nil); end
  def load_ejson_from_file; end
  def logger(*args, &block); end
  def namespace(*args, &block); end
  def private_key; end
  def public_key; end
  def resources; end
  def validate_secret_spec(secret_name, spec); end
  def with_decrypted_ejson; end
end
class Krane::Renderer
  def bind_template_variables(erb_binding, variables); end
  def find_partial(name); end
  def initialize(current_sha:, template_dir:, logger:, bindings: nil); end
  def render_partial(partial, locals); end
  def render_template(filename, raw_template); end
  def template_variables; end
end
class Krane::Renderer::InvalidPartialError < Krane::InvalidTemplateError
  def content; end
  def content=(arg0); end
  def filename; end
  def filename=(arg0); end
  def initialize(msg, filename:, parents: nil, content: nil); end
  def parents; end
  def parents=(arg0); end
end
class Krane::Renderer::PartialNotFound < Krane::InvalidTemplateError
end
class Krane::Renderer::TemplateContext
  def initialize(renderer); end
  def partial(partial, locals = nil); end
  def template_binding; end
end
module DelayedExceptions
  def with_delayed_exceptions(enumerable, *catch, &block); end
end
class Krane::TemplateSets
  def deploying_with_erb_files?; end
  def ejson_secrets_files; end
  def initialize(template_sets: nil); end
  def rendering_erb_disabled?; end
  def self.from_dirs_and_files(paths:, logger:, render_erb: nil); end
  def validate; end
  def with_resource_definitions(current_sha: nil, bindings: nil, raw: nil); end
  def with_resource_definitions_and_filename(current_sha: nil, bindings: nil, raw: nil); end
  include DelayedExceptions
end
class Krane::TemplateSets::TemplateSet
  def deploying_with_erb_files?; end
  def ejson_secrets_file; end
  def initialize(template_dir:, logger:, file_whitelist: nil, render_erb: nil); end
  def render_erb; end
  def templates(filename:, raw:); end
  def validate; end
  def with_resource_definitions_and_filename(current_sha: nil, bindings: nil, raw: nil); end
  include DelayedExceptions
end
class Krane::DeployTaskConfigValidator < Krane::TaskConfigValidator
  def initialize(protected_namespaces, prune, *arguments); end
  def validate_protected_namespaces; end
end
module Krane::TemplateReporting
  def add_para_from_list(logger:, action:, enum:); end
  def record_invalid_template(logger:, err:, filename:, content: nil); end
  def record_warnings(logger:, warning:, filename:); end
end
class Krane::ResourceDeployer
  def apply_all(*args, **kwargs, &block); end
  def create_resource(resource); end
  def deploy!(resources, verify_result, prune); end
  def deploy_all_resources(*args, **kwargs, &block); end
  def deploy_resources(resources, verify:, prune: nil, record_summary: nil); end
  def find_bad_files_from_kubectl_output(line); end
  def initialize(task_config:, prune_whitelist:, global_timeout:, selector:, statsd_tags:, current_sha: nil); end
  def kubectl; end
  def log_pruning(kubectl_output); end
  def logger(*args, &block); end
  def predeploy_priority_resources(*args, **kwargs, &block); end
  def record_apply_failure(err, resources: nil); end
  def replace_or_create_resource(resource, force: nil); end
  def statsd_tags; end
  extend Krane::StatsD::MeasureMethods
  include Krane::TemplateReporting
end
module Krane::ResourceDeployer::InstrumentationProxy
  def apply_all(*args, **kwargs, &block); end
  def deploy_all_resources(*args, **kwargs, &block); end
  def predeploy_priority_resources(*args, **kwargs, &block); end
end
class Krane::DeployTask
  def check_initial_status(*args, **kwargs, &block); end
  def cluster_resource_discoverer; end
  def confirm_ejson_keys_not_prunable; end
  def deploy_has_priority_resources?(resources); end
  def discover_resources(*args, **kwargs, &block); end
  def ejson_keys_secret; end
  def ejson_provisioners; end
  def initialize(namespace:, context:, current_sha: nil, logger: nil, kubectl_instance: nil, bindings: nil, global_timeout: nil, selector: nil, filenames: nil, protected_namespaces: nil, render_erb: nil); end
  def kubeclient_builder; end
  def kubectl; end
  def namespace_definition; end
  def predeploy_sequence; end
  def prune_whitelist; end
  def resource_deployer; end
  def run!(verify_result: nil, prune: nil); end
  def run(**args); end
  def secrets_from_ejson; end
  def server_version; end
  def statsd_tags; end
  def tags_from_namespace_labels; end
  def validate_configuration(*args, **kwargs, &block); end
  def validate_globals(resources); end
  def validate_resources(*args, **kwargs, &block); end
  def with_retries(limit); end
  extend Krane::StatsD::MeasureMethods
  include Krane::TemplateReporting
end
module Krane::DeployTask::InstrumentationProxy
  def check_initial_status(*args, **kwargs, &block); end
  def discover_resources(*args, **kwargs, &block); end
  def validate_configuration(*args, **kwargs, &block); end
  def validate_resources(*args, **kwargs, &block); end
end
class Krane::RenderTask
  def initialize(current_sha:, bindings:, logger: nil, filenames: nil); end
  def log_invalid_template(exception); end
  def render_templates(stream, template_sets); end
  def run!(stream:); end
  def run(**args); end
  def validate_configuration(template_sets); end
  def write_to_stream(rendered_content, filename, stream); end
end
class Krane::RestartTask
  def apps_v1_kubeclient; end
  def build_patch_payload(deployment); end
  def build_watchables(kubeclient_resources, started); end
  def fetch_deployments(list); end
  def identify_target_deployments(deployment_names, selector: nil); end
  def initialize(context:, namespace:, logger: nil, global_timeout: nil); end
  def kubeclient; end
  def kubeclient_builder; end
  def kubectl; end
  def patch_deployment_with_restart(record); end
  def patch_kubeclient_deployments(deployments); end
  def perform!(deployments: nil, selector: nil, verify_result: nil); end
  def perform(**args); end
  def run!(deployments: nil, selector: nil, verify_result: nil); end
  def run(**args); end
  def tags(status, deployments); end
  def v1beta1_kubeclient; end
  def verify_config!; end
  def verify_restart(resources); end
end
class Krane::RestartTask::FatalRestartError < Krane::FatalDeploymentError
end
class Krane::RestartTask::RestartAPIError < Krane::RestartTask::FatalRestartError
  def initialize(deployment_name, response); end
end
class Krane::RunnerTaskConfigValidator < Krane::TaskConfigValidator
  def initialize(template, *arguments); end
  def validate_template; end
end
class Krane::ContainerOverrides
  def apply!(container); end
  def arguments; end
  def command; end
  def env_vars; end
  def image_tag; end
  def initialize(command: nil, arguments: nil, env_vars: nil, image_tag: nil); end
end
class Krane::RunnerTask
  def build_pod(template_name, container_overrides, verify_result); end
  def build_pod_definition(base_template); end
  def create_pod(pod); end
  def ensure_valid_restart_policy!(template, verify); end
  def extract_task_runner_container(pod_definition); end
  def get_template(template_name); end
  def initialize(namespace:, context:, logger: nil, global_timeout: nil); end
  def kubeclient; end
  def kubeclient_builder; end
  def kubectl; end
  def pod_name; end
  def record_status_once(pod); end
  def run!(template:, command:, arguments:, env_vars: nil, image_tag: nil, verify_result: nil); end
  def run(**args); end
  def statsd_tags(status); end
  def validate_pod(pod); end
  def verify_config!(task_template); end
  def watch_pod(pod); end
end
class Krane::RunnerTask::TaskTemplateMissingError < Krane::TaskConfigurationError
end
class Krane::GlobalDeployTaskConfigValidator < Krane::TaskConfigValidator
  def initialize(*arguments); end
end
class Krane::GlobalDeployTask
  def check_initial_status(*args, **kwargs, &block); end
  def cluster_resource_discoverer; end
  def context(*args, &block); end
  def deploy!(resources, verify_result, prune); end
  def discover_resources(*args, **kwargs, &block); end
  def global_kinds(*args, &block); end
  def initialize(context:, global_timeout: nil, selector: nil, filenames: nil, logger: nil); end
  def kubeclient_builder; end
  def kubectl; end
  def logger(*args, &block); end
  def prune_whitelist; end
  def run!(verify_result: nil, prune: nil); end
  def run(**args); end
  def statsd_tags; end
  def validate_configuration(*args, **kwargs, &block); end
  def validate_globals(resources); end
  def validate_resources(*args, **kwargs, &block); end
  extend Krane::StatsD::MeasureMethods
  include Krane::TemplateReporting
end
module Krane::GlobalDeployTask::InstrumentationProxy
  def check_initial_status(*args, **kwargs, &block); end
  def discover_resources(*args, **kwargs, &block); end
  def validate_configuration(*args, **kwargs, &block); end
  def validate_resources(*args, **kwargs, &block); end
end
